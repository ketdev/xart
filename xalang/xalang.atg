// [IMPORTS]
#include <wchar.h>
#include <string>
#include <iostream>
#include <locale>
#include <codecvt>
using namespace std;

#include "Code.h"
using namespace xalang;

/*--------------------------------------------------------------------------*/
COMPILER Xalang

    // PARSER fields and methods
    
	static inline std::wstring s2ws(const std::string& str) {
		using convert_typeX = std::codecvt_utf8<wchar_t>;
		std::wstring_convert<convert_typeX, wchar_t> converterX;
		return converterX.from_bytes(str);
	}
	static inline std::string ws2s(const std::wstring& wstr) {
		using convert_typeX = std::codecvt_utf8<wchar_t>;
		std::wstring_convert<convert_typeX, wchar_t> converterX;
		return converterX.to_bytes(wstr);
	}

	wstring tokenText(){
		return coco_string_create(t->val);
	}

	bool isDecl() {
		scanner->ResetPeek();
		Token* next = scanner->Peek();
		while(next->kind == _t_ident || next->kind == _t_comp)
			next = scanner->Peek();
		return la->kind == _t_ident && next->kind == _t_decl;
	} 
	bool isFunc() {
		scanner->ResetPeek();
		Token *next = scanner->Peek();
		while(next->kind == _t_ident || next->kind == _t_comp)
			next = scanner->Peek();
		return la->kind == _t_ident && next->kind == _t_params_start;
	} 

	// Code generation

	Module root;


/*--------------------------------------------------------------------------*/
CHARACTERS

	tab                = '\u0009'. /*  9 = tabulator */
	lf                 = '\u000a'. /* 10 = line feed */
	cr                 = '\u000d'. /* 13 = carriage return */
	ws                 = ' ' + tab + '\u000b' + '\u000c'. /* Any character with Unicode class Zs */

	letter             = 'A' .. 'Z' + 'a' .. 'z'.
	digit              = '0' .. '9'.
	hex                = digit + 'A' .. 'F' + 'a' .. 'f'.
	oct                = '0' .. '7'.
	bin                = '0' .. '1'.
	char                = ANY - '"' - "'".

TOKENS

	t_eol				= lf.
	t_ident				= ['_'] letter { letter | digit | '_' }.
	t_integer           = ['-'] digit {digit} | ("0x"|"0X") hex {hex} | ("0o"|"0O") oct {oct} | ("0b"|"0B") bin {bin}.
	t_real              = ['-'] digit {digit} ( '.' digit {digit} [('E'|'e') ['+'|'-'] digit {digit}] 
										      |                    ('E'|'e') ['+'|'-'] digit {digit}).
	t_string            = '"'{char|"'"}'"' | "'"{char|'"'}"'".

	// special tokens
	t_priv				= '_'.
	t_comp				= '.'.
	t_sep				= ','.
	t_decl				= ':'.
	t_params_start		= '['.
	t_params_end   		= ']'.
	t_par_start			= '('.
	t_par_end			= ')'.

	// keywords
	t_module			= "module".
	t_true				= "True".
	t_false				= "False".
	t_null				= "Null".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO cr lf
COMMENTS FROM "#" TO cr lf

IGNORE cr + ws + tab


/*------------------------------------------------------------------------*/
PRODUCTIONS

// Basic Type parsing ---------------------------------------------------------

value<Value &val> =				(. val = {}; .)
	( t_integer					(. val.type = Value::Integer; .)
	| t_real					(. val.type = Value::Real; .)
	| t_string					(. val.type = Value::String; .)
	| t_true					(. val.type = Value::Boolean; .)
	| t_false					(. val.type = Value::Boolean; .)
	| t_null					(. val.type = Value::Null; .)
	)							(. val.text = tokenText(); .)
.

// '_' for private, capital for constant
ident<Ident &t> = t_ident		(.  t.name = tokenText();
									t.isPrivate = (t.name[0] == _t_priv);
									t.isConstant = (t.isPrivate ? 
										iswupper(t.name[1]) : 
										iswupper(t.name[0]));   
								.)
.

// components separated by '.'
symbol<Symbol& t> =				(. t = {}; Ident id; .)
	ident<id>					(. t.push_back(id); .)
	{ t_comp ident<id>			(. t.push_back(id); .) 
	}
.


// Expressions - code data and transformations --------------------------------

Xalang = t_module symbol<root.name> block<root.scope>.

// newline separated lists
block<Scope &s> = { {t_eol} list<s> {t_eol} }.

// ',' separated items
list<Scope &s> = 
	item<s> { t_sep {t_eol} item<s> }		// a,b,c
.

item<Scope &s> =					(. Expr e; .)
	( value<e.val>					(. e.type = Expr::Value; .)
	| IF(isDecl()) 
		declaration<e.decl>			(. e.type = Expr::Declaration; .)
	| evaluation<e.eval>			(. e.type = Expr::Evaluation; .)	
	)								(. s.push_back(e); .)
	| t_par_start block<s> t_par_end
.

declaration<Declaration& d> = 
	symbol<d.sym> t_decl {t_eol} list<d.layout>		// a: b,c
.

evaluation<Evaluation& e> = 
	symbol<e.sym> [ list<e.layout> ]	// a (b,c)
.



/*------------------------------------------------------------------------*/
END Xalang.
