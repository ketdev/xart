module sample

// import os
// import io
// import math


// Order of tokens:
//	'(' ')'		- parenthesis
//	'\n'		- list hard break
//	':'			- declaration
//	',' 		- list soft break
//	' '			- evaluation
//	'.'			- subcomponent
//	'#'			- index

// rules:
// #1 - no declaration within declaration list without parenthesis

// equivalents:
//	':(...)' == '{...}'


// -- DATA VALUES --

// Define some data entities
myColor: "blue"

// Data is a tuple
// start with uppercase for constant values
math.Coordinate: 2,3

// Data can also hold types
myTypes: int, int

// Held types can have aliases
//point: x:int, y:int	// rule #1 -> (point: <error>) (x:int), (y:int)
//point: (x:int, y:int) // rule #1 -> point: ((x:int), (y:int))

// lookahead for declarations
//a: 1, 3, b: 2	// apply rule #1, 'b' decl cannot be within 'a' decl
(a: 1, 3), (b: 2)

// Can be accessed by name or index
point.x
//point.#i.run test


// -- CODE --


io.print ('hello world!') 

# parenthesis are optional, used solely for operation order, so this is ok!
(io.print 'cool!')



/*


// --

// Define a transformation function
// applies to any data with matching components (in the same module?)
program [] {
	// ...
}

// Define custom type component
point {
	x:int 
	y:int
}

// : is eager, [] is lazy (parametrized)
// F is constant, f is variable

Foo [] {		// Function (parametrized data)
	var: 1
	var2: var + Red
}

Entry [args..] {
	ret 0
}

// Foo [] {
// 	ret A	// <- ret only if parametrized transformation?
// }
// 
// Foo == Foo.x
// 
// MyVal 3


////////////////////////////

// Component {}
// Entity : Components
// System [Components] {}


// Component - simple, logic-less data-containing struct
// Tag - simple logic-less and data-less truct
point { // component
	x : int
	y : int
}
dead {} // tag

// Signature - compiletime mixed list of required components and tags
-> in language, part of system signature

KillEnemy [point, dead]{ // system
	...
}

// ComponentList - compiletime list of component types
// TagList - compiletime list of tag types
// SignatureList - compiletime list of signature types

// Entity - Simple struct "pointing" to the correct omponent data.
//			Contains a bitset to keep track of available components and tags, 
//			and a flag to check if the entity is alive
// Manager - Context class. Will contain entities, components signatures, metadata.
//			It will deal with entity/component creation/removal, with entity iteration and much more.
// Handle - Layer of indirection betweent the entities and the user.
//			Handles will be used to keep track and access an entity.
//			It will be possible to check if the entity is still valid through an existing handle.


*/